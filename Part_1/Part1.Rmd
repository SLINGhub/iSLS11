---
title: "Data Preprocessing and QC"
author: "Bo Burla"
subtitle: 'Part 1: iSLS11 Clinical Lipidomics Data Analysis Workshop'
output:
  html_document:
    df_print: paged
bibliography: references.bib
editor: visual
---

## Introduction

In this workshop, we will walk you through the data analysis of a lipidomics dataset, from data preprocessing and data quality control to statistical analyses and interpretation. We will be using the data and analysis published by Tan et al. on '*Variability of the Plasma Lipidome and Subclinical Coronary Atherosclerosis*' [@tan2022a] as an example for this workshop. The plasma lipidomics data from this study were obtained using liquid chromatography-tandem mass spectrometry( LC-MS/MS) with multiple reaction monitoring (MRM).

In this first part, we will inspect and process the targeted mass spectrometry (MS)-based plasma lipidomics raw dataset, starting from peak areas, moving to data quality control and ending with a table of QC-filtered lipid concentration values. Careful inspection and quality control of an lipidomics raw data is essential for having a high quality dataset. Moreover, the data processing itself can be a source of errors, noise and artefacts. We therefore follow the approach of an automated, but supervised, preprocessing workflow where we perform checks of each preprocessing step.

![**Figure 1:** Data Processing and QC workflow. Processing steps are indicated by blue boxes, quality control steps by the red boxes. Dotted arrows indicate re-run previous steps. (B. Burla, unpublished)](images/image-1807848975.png){style="text-align: center;" width="525"}

## R packages used

We first load packages used in this part of the workshop. We will employ several packages from the [`tidyverse`](https://www.tidyverse.org) which can be loaded using `library(tidyverse)`. The [`here`](https://here.r-lib.org) package provides the function `here()` that returns the root of the project. [`broom`](https://broom.tidymodels.org) provides functions to convert outputs of standard R functions such as `t.test` and `lm` into [tidy tables](https://r4ds.had.co.nz/tidy-data.html) (dataframes/tibbles). [`ggpmisc`](https://github.com/aphalo/ggpmisc) extends `ggplot2` with functions useful for plotting models and annotations of axes.

```{r setup}
knitr::opts_chunk$set(collapse = TRUE, echo = TRUE, fig.height=4, fig.width=10)

library(tidyverse)
library(here)
library(broom)
library(ggpmisc)
here::i_am("Part_1/Part1.qmd")
here::here()
```

## Importing raw data

We start with loading the table with peak areas, which were obtained after peak integration of LC-MS raw data using MRMkit [@teo].

It is always good to check the whether the data was imported correctly, e.g. by inspecting column types. For example, undefined text indicating missing values (e.g. *ND*) within numerical columns, can lead the `read_csv()` to assign a column as text.

```{r import-raw}

d_orig <- readr::read_csv(file = here("Part_1/data/SPERFECT_SLINGpanel_MRMkit_RawAreas_clean.csv"),col_names = TRUE, trim_ws = TRUE, na = c("NA", "ND", "n.d."))
d_orig
```

## Prepare and convert to a long format table

First we clean the imported dataset for easier handling later on. Inconsistent sample and lipid names can be problematic as well and may need to be fixed. In our case, we just clean the sample names by removing `.mzML`. Since the file/sample names do not contain any information on the analysis order, we furthermore add the runorder number `RUN_ID` as first column, knowing that the imported data was in the analysis sequence.

In the second step, we convert the data into the *long (narrow) format*. In the long format, every observation ( = every lipid/sample pair) is a row and columns represent measured variables (e.g. peak area, RT) for each observation (pair) is a row. Especially in this phase of the data analysis the long format is helpful.

![**Figure 2**: Wide vs long-format tables. Columns in blue describe the samples, and in grey peak areas. In red is an additional variable not present in the wide table.](images/image-381159423.png){width="467"}

We can convert the format easily in R using the `dplyr` [`pivot`](https://tidyr.tidyverse.org/articles/pivot.html) functions

```{r reshape}
d_orig <- d_orig |> 
  mutate(FILENAME = stringr::str_replace(FILENAME, ".mzML", "")) |> 
  mutate(RUN_ID = row_number(), .before = 1)

d_long <- d_orig |>  
  pivot_longer(names_to = "LIPID", values_to = "AREA", cols = -RUN_ID:-QC_TYPE) %>% 
  arrange(LIPID)

d_long
```

## First look at the data: plotting responses *vs* run order

Now we are ready to have a first look on how the analysis went. For this we inspect the peak areas of internal standards (ISTDs) over the analysis sequence by plotting them. Different QC samples were included in this analysis, which serve different functions (see also: [@broadhurstGuidelinesConsiderationsUse2018]):

-   BQC: Batch (Process) QC
-   TQC: Technical (instrument) QC
-   PBLK: Process (extraction) Blank
-   SBLK: Solvent Blank
-   RQC: Response QCs

```{r plot-runscatter-areas, fig.height=5}

# Filter for ISTDs only
d_istd <- d_long %>% filter(str_detect(LIPID, "ISTD"))
#d_plot <- d_long %>% filter(str_detect(LIPID, "ISTD") & str_detect(LIPID, "Cer"))

# Convert QC_TYPE to a factor and sort, to ensure correct layering in plot
d_istd$QC_TYPE <- factor(d_istd$QC_TYPE, c("SAMPLE", "BQC", "TQC", "PBLK", "RQC"))
d_istd <- d_istd |> arrange(QC_TYPE)

# Define colors and shapes for each QC_TYPE
qc_colors <- c(SAMPLE = "grey50", BQC = "red", TQC = "blue", 
               PBLK = "green", SBLK = "darkgreen", RQC = "pink3")

qc_shapes <- c(SAMPLE = 1, BQC = 21, TQC = 21, 
               PBLK = 21, SBLK = 23, RQC = 6)

# Plot
 p <- ggplot(d_istd, aes(x=RUN_ID, y=AREA)) + 
        geom_point(aes(colour = QC_TYPE, fill = QC_TYPE, shape  = QC_TYPE),
                   size = 1, alpha =0.7, stroke = 0.3) +
        facet_wrap(vars(LIPID), ncol = 5, nrow = 4, scales="free_y") +
        scale_shape_manual(na.value = NA, values = qc_shapes) +
        scale_fill_manual(values = qc_colors, na.value = NA) +
        scale_colour_manual(values = qc_colors, na.value = NA) +
        scale_x_continuous(breaks = seq(0, max(d_istd$RUN_ID), by = 100 )) + 
        scale_y_continuous(limits = c(0, NA)) + 
        theme_bw(base_size = 8) 
plot(p)
ggsave(plot = p, filename = here("Part_1/output/runscatter_ISTD.pdf"),
       width = 280, height = 180, units = "mm")
```

| We observe that the intensity of some ISTDs shows a drift during the analysis. The two ceramide ISTDs show a very different pattern, even they are from the same class.
| The variability of the signals of the ISTD in the samples is comparable to the QCs (BQC and TQC), indicating that the ISTDs are not subjected to a major matrix effect. We also observe that signals of the ISTDs in the **PBLK** (processed blank) containg ISTDs is comparable to the other sample types, suggesting now major matrix suppression or interference. For LPC 18:1 d7 the signals are lower in the samples than in the PBLK.

## Checking Linear Response

Injected sample amount need to be carefully chose when measuring analytes covering a large concentration range. It is a trade-off between sensitivity and not exceeding the linear range of the measurement, as well as other factors. While protocols define an optimal injected sample amount (volume), the linear range of the the LC-MS system can change, even within an longer analysis sequence. We therefore always check the linear response as a QC, using dilution, or injection volume, series of a pooled QC extract.

Let's plot the response curves from ISTDs measured at the beginning and end of this run. For this we extract the curve number and relative concentration from the sample name.

```{r plot-response}

d_rqc <- d_long |> 
  filter(QC_TYPE == "RQC") |> 
  separate(col = FILENAME, 
           into = c("TYPE","CURVE_NO","AMOUNT"), 
           sep = "-", 
           remove = FALSE, convert = TRUE)
d_rqc$CURVE_NO <- factor(d_rqc$CURVE_NO)
d_rqc$AMOUNT <- as.numeric(d_rqc$AMOUNT)

p <- ggplot(d_rqc |> filter(str_detect(LIPID, "ISTD")), 
            aes(x=AMOUNT, y=AREA, color = CURVE_NO, group = CURVE_NO)) +
        geom_point(size = 2, alpha =0.7, stroke = 0.3) +
        facet_wrap(vars(LIPID), ncol = 5, nrow = 4, scales="free_y") +
        ggpmisc::stat_poly_line(linewidth = 0.5, se = FALSE) +
        ggpmisc::stat_poly_eq(aes(label = after_stat(rr.label)),
                     size = 2.4,
                     lineheight = 1, ) +
        scale_colour_manual(values = c("1" = "cyan4", "2" ="blue3")) +
        scale_x_continuous(limits = c(0, NA)) + 
        scale_y_continuous(limits = c(0, NA)) + 
        labs(x = "Rel. Sample Amount (%)") +
        theme_bw(base_size = 8) 
plot(p)
ggsave(plot = p, filename = here("Part_1/output/reponse_curves.pdf"),
       width = 280, height = 120, units = "mm")
```

| We see that the response is fairly linear for most species, whereby the TG ISTD shows some saturation. The two curves mostly overlap, suggesting no major changes in sensitivity and linearity over this time, except Cer d18:1/12:0 that showed a considerable drift (see Figure 1).

## Check lipid identifications

```{r identcheck}

d_lipids <- readr::read_csv(file = here("Part_1/data/SPERFECT_SLINGpanel_MRMkit_peakQC.csv"))

d_lipids <- d_lipids |>
  mutate(LIPID_tmp = str_replace(LIPID, " O\\-", "-O "),
         LIPID_tmp = str_replace(LIPID, " P\\-", "-P "), .after = LIPID) |> 
  separate(LIPID_tmp, into = c("CLASS", "CHAINS", "OTHER"), 
           sep = " ", remove = TRUE, extra = "drop")



```

## Normalization and quantification

```{r process-data}
d_istd_map <- readr::read_csv(file = here("Part_1/data/ISTD_mapping.csv"),
                          col_names = TRUE, trim_ws = TRUE, col_types = "c")

d_istd_conc <- readr::read_csv(file = here("Part_1/data/ISTD_conc.csv"),
                          col_names = TRUE, trim_ws = TRUE, col_types = "c")

d_processed <- d_long |> 
  left_join(d_istd_map, by = c("LIPID")) |> 
  left_join(d_istd_conc, by = c("ISTD")) |> 
  mutate(isISTD = (LIPID == ISTD)) |> 
  group_by(ISTD, FILENAME) |> 
  mutate(normAREA = AREA/AREA[isISTD],
         CONC = normAREA * RF * ISTD_conc_nM/1000 * 4.5/ 10) |> 
  ungroup()
```

## Inspect normalized data

Normalization with the class-specific ISTD often helps to remove systematic drifts and batch effects, but may also introduce additional noise and artefacts. Let's have a look on the how the data looks after normalization.

Before we plotted the ISTD runscatter in one page, however if we would like to look at all spececies we could distribute the plots over several pages. There are different ways to archive this. One possibility is using `facet_wrap_paginate()` from the `ggforce` package, but this can be slow when having large datasets. We here are using another, manual, approach, by slicing the long table into pages that will then be plotted.

```{r plot-runscatter-conc, warning: false, message: false}

plot_page <- function(data, nrows, ncols){
 ggplot(data, aes(x=RUN_ID, y=CONC)) + 
        geom_point(aes(colour = QC_TYPE, fill = QC_TYPE, shape  = QC_TYPE),
                   size = 1, alpha =0.7, stroke = 0.3) +
        facet_wrap(vars(LIPID), ncol = ncols, nrow = nrows, scales="free_y") +
        scale_shape_manual(na.value = NA, values = qc_shapes) +
        scale_fill_manual(values = qc_colors, na.value = NA) +
        scale_colour_manual(values = qc_colors, na.value = NA) +
        scale_x_continuous(breaks = seq(0, max(d_istd$RUN_ID), by = 100 )) + 
        scale_y_continuous(limits = c(0, NA)) + 
        theme_bw(base_size = 8) 
 }

rows_page = 5
columns_page = 5

#get a table with page numbers for each lipid species
d_pages <- d_processed |> 
  select(LIPID) |> 
  distinct() |> 
  mutate(page_no = ceiling(row_number() / (rows_page * columns_page)))
#plot each page from a nested table
d_plots <- d_processed %>%
  filter(!str_detect(QC_TYPE, "BLK|RQC"), !str_detect(LIPID, "ISTD")) |> 
  left_join(d_pages, by = join_by(LIPID)) %>%
  nest(.by = page_no) %>%
  mutate(plt = map(data, ~ plot_page(., rows_page, columns_page)))

# Save pages to a PDF. 
pdf(file = here("Part_1/output/run_scatter_CONC_all.pdf"),onefile = TRUE,
       width = 280/25.4, height = 180/25.4)
#d_plots$plt 
invisible(purrr::walk(d_plots$plt, print)) # use this to prevent printing of index
dev.off()
```

## Calculate quality-control (QC) values for each lipid species

To evaluate the quality of the analysis and to filter the date we calculate different QC values for each lipid species. This included the analytical coefficient of variation (CV) based on the BQCs, the signal-to-blank ratio, and the r squared of the response curves.

```{r calc-qc}

rsd <- function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE)

d_qc_1 <- d_processed |> 
  group_by(LIPID) |> 
  summarise(
    Area_SPL = median(AREA[QC_TYPE == "SAMPLE"], rm.na = TRUE),
    SB_ratio = Area_SPL/median(AREA[QC_TYPE == "PBLK"], rm.na = TRUE),
    Conc_SPL = median(CONC[QC_TYPE == "SAMPLE"], rm.na = TRUE),
    CV_TQC = rsd(CONC[QC_TYPE == "TQC"]) * 100,
    CV_BQC = rsd(CONC[QC_TYPE == "BQC"]) * 100,
    CV_SPL = rsd(CONC[QC_TYPE == "SAMPLE"]) * 100,
    D_ratio = sd(CONC[QC_TYPE == "BQC"])/sd(CONC[QC_TYPE == "SAMPLE"])
  ) |> ungroup()

f <- function(x) broom::glance(lm(AREA ~ AMOUNT, data = x))

d_qc_2 <- d_rqc |> 
  nest(.by = c(LIPID, CURVE_NO)) |> 
  mutate(res = purrr::map(data, f)) |> 
  unnest(res)

d_qc_2 <- d_qc_2 |> 
  select(LIPID, CURVE_NO, r.squared, p.value) |> 
  pivot_wider(names_from = CURVE_NO, values_from = c(r.squared, p.value))

d_qc <- d_lipids |> 
  left_join(d_qc_1, by = join_by(LIPID)) |> 
  left_join(d_qc_2, by = join_by(LIPID))

write_csv(x = d_qc, file = here("Part_1/output/QC-summary.csv"))
```

## QC filter and save dataset

```{r qc-filter}
d_qc <- d_qc |> 
  mutate( 
    QC_pass = 
    (CV_BQC < 25 | (CV_BQC < 50 & D_ratio < 0.5)) & 
    SB_ratio > 3 &
    r.squared_1 > 0.8 &
    QUANTIFIER &
    !str_detect(LIPID, "ISTD"))

```

## Inspect QC results

We now can (and should) have a look at how many species passed the QC criteria and if there are any pattern specific to lipid classes.

```{r plot-qc-filter}

d_qc_summary <- d_qc |> filter(QUANTIFIER) |> dplyr::count(CLASS, QC_pass) 

ggplot(d_qc_summary, 
       aes(x = CLASS, y = n, fill = QC_pass, group = QC_pass)) +
  geom_bar(position="stack", stat="identity") + 
  scale_fill_manual(values = c("FALSE" = "#d6cac9", "TRUE" = "green4")) + 
  scale_x_discrete(limits=rev)+
  coord_flip() + theme_bw()
```

# Parse lipid names and save final dataset

```{r save-processed-data}

# QC filter data
d_final <- d_processed |> 
  filter(QC_TYPE == "SAMPLE", !str_detect(LIPID, "ISTD")) |> 
  right_join(d_qc[d_qc$QC_pass,"LIPID"], by = join_by(LIPID))

d_final_wide <- d_final |> 
  pivot_wider(id_cols = c(FILENAME, QC_TYPE), names_from = "LIPID", values_from = "CONC") 

write_csv(d_final_wide, here("Part_1/output/qc_filtered_results.csv"))
write_csv(d_final_wide, here("Part_2/output/qc_filtered_results.csv"))
```

# References
